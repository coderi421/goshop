package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"regexp"
	"strings"
)

var buf bytes.Buffer

func main() {
	fileName := "E:/zhuomian/project/v2/mxshop/app/pkg/code/user.go"
	//这个不需要过度的关心，得看源码，第3个选项是可以传代码 不用传文件，第4个是解析模式
	f, err := parser.ParseFile(token.NewFileSet(), fileName, nil, parser.ParseComments) //解析模式
	if err != nil {
		panic(err)
	}
	fmt.Fprintf(&buf, "// Code generated by \"codegen %s\";DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	fmt.Fprintf(&buf, "\n")
	fmt.Fprintf(&buf, "package %s", "code")
	fmt.Fprintf(&buf, "\n")

	fmt.Fprintf(&buf, "func init() {\n")
	//断言成GenDecl
	genDecl(f.Decls[0].(*ast.GenDecl))
	fmt.Fprintf(&buf, "}\n")
	src := []byte(buf.String())
	err = os.WriteFile("E:/zhuomian/project/v2/mxshop/app/pkg/code/code_generated.go", src, 0o600)
	if err != nil {
		panic(err)
	}
}

func genDecl(decl *ast.GenDecl) {
	for _, s := range decl.Specs {
		//断言成ValueSpec继续解析
		v := s.(*ast.ValueSpec)
		//考虑到有多个name，比如：ErrUserNotFound2,ErrUserNotFound3=1,2
		for _, name := range v.Names {
			var comment string
			//考虑到注释有/**/
			if v.Doc != nil && v.Doc.Text() != "" {
				comment = v.Doc.Text()
				//再考虑//
			} else if c := v.Comment; c != nil && len(c.List) == 1 {
				comment = c.Text()
			}
			httpCode, desc := ParseComment(name.Name, comment)
			fmt.Fprintf(&buf, "\tregister(%s, %s, \"%s\")\n", name.Name, httpCode, desc)
			fmt.Println(name.Name, httpCode, desc)
		}
	}
}

func ParseComment(varName, comment string) (httpCode, desc string) {
	reg := regexp.MustCompile(`\w\s*-\s*(\d{3})\s*:\s*([A-Z].*)\s*\.\n*`)
	if !reg.MatchString(comment) {
		return "500", "Internal server error"
	}
	groups := reg.FindStringSubmatch(comment)
	//隐含有3块分组
	if len(groups) != 3 {
		return "500", "Internal server error"
	}
	return groups[1], groups[2]
}
